% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fpca_sgc.R
\name{fpca.sgc.lat}
\alias{fpca.sgc.lat}
\title{Functional principal component analysis of continuous, truncated and discrete functional data}
\usage{
fpca.sgc.lat(
  X,
  type,
  argvals = NULL,
  df = 5,
  T_out = NULL,
  npc = 4,
  scores = FALSE,
  impute = FALSE,
  min_no_pairs = 30,
  weights = TRUE,
  posd_tol = 1e-08
)
}
\arguments{
\item{X}{A numeric data matrix (n by m), n is the sample size and m is the number of time-points. Binary values must be coded as 0, 1. Ordinal values with l ordered categories must be coded as 0, 1, 2, ... , (l-1).}

\item{type}{A character denoting the type of variable in \code{X}, must be in the format "cont", "trunc", "ord", "bin".}

\item{argvals}{A vector of length m denoting the argument values of the functions. If NULL, we default it to an equidistant grid from 0 to 1.}

\item{df}{An integer denoting the degrees of freedom corresponding to the basis function.}

\item{T_out}{If supplied, the estimated covariance and FPCA is returned on this grid of argument values (time-points)}

\item{npc}{Prescribed value for the number of principal components. Defaults to 4.}

\item{scores}{A logical variable indicating if the user wants to return FPC scores or not.}

\item{impute}{A logical variable indicating whether missing values should be imputed before calculating FPC scores.}

\item{min_no_pairs}{The minimum number of pairs of observations used to calculate Kendall's Tau (otherwise report NA)}

\item{weights}{A logical variable indicating whether objective function needs to be weighted inversely proportional to sample size for each pair}

\item{posd_tol}{If supplied, the posd_tol passed onto nearPD for nearest positive definite matrix}
}
\value{
\code{fpca.sgc.lat} returns
\itemize{
\item{cov: }{the estimated m by m covariance matrix}
\item{cov_out:}{If T_out is provided, the output covariance matrix calculated on the T_out grid}
\item{efunctions: }{first npc number of eigenfunctions}
\item{evalues: }{first npc number of eigenvalues}
\item{latent: }{predictions of latent continuous trajectories, if \code{scores == TRUE}}
\item{scores: }{first npc number of PC scores, if \code{scores == TRUE}}
\item{par: }{Estimated parameters from the nls algorithm}
\item{vcov:}{Variance-covariance matrix of the estimatd parameters from the nls algorithm}
}
}
\description{
Covariance estimation and functional principal component analysis (FPCA) of continuous/truncated/ordinal/binary functional data based on the latent Semiparametric Gaussian copula process.
}
\examples{
require(SGCTools)

matern <- function (u, phi, kappa)
{
  if (is.vector(u))
    names(u) <- NULL
  if (is.matrix(u))
    dimnames(u) <- list(NULL, NULL)
  uphi <- u/phi
  uphi <- ifelse(u > 0, (((2^(-(kappa - 1)))/ifelse(0, Inf,
                                                    gamma(kappa))) * (uphi^kappa) * besselK(x = uphi, nu = kappa)),
                 1)
  uphi[u > 600 * phi] <- 0
  return(uphi)
}

n <- 1000
m <- 15
delta <- 0.5 # cutoff
cmb <- combn(m,2)
tp = seq(0,1,length=m)
d = abs(outer(tp,tp,"-")) # compute distance matrix, d_{ij} = |x_i - x_j|
phi=2 # length scale
l=0.01

# Generate covariance matrix from stationary kernel
Sigma_SE = matern(d,phi= 1/phi, kappa= 3.5) # Matern exponential kernel

# generate latent process
set.seed(1)
y = mvtnorm::rmvnorm(n,sigma=Sigma_SE)

# generate observed process based on the cutoff
z = y
z[z>delta]=1
z[z<=delta]=0

# run fpca.sgc.lat to get functional principal component analysis of binary data
ff = fpca.sgc.lat(X=z,type="bin",argvals = tp, df= 4)

# compare truth vs estimate
par(mfrow=c(1,2))
image(as.matrix(Sigma_SE), main="Truth")
image(as.matrix(ff$cov), main="Estimate")
}
\references{
Dey D., Ghosal R., Merikangas K., Zipunnikov V. (2023) "Covariance Estimation and Principal Component Analysis for Mixed-Type Functional Data with application to mHealth in Mood Disorders" \url{https://arxiv.org/abs/2306.15084}
}
